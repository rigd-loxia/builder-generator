package nl.loxia.builder.generator.ap.test.builderchaining;

/**
 * Generated by RIGD-Loxia Builder generator
 */
public class BuilderListChainingBuilder<PARENT> {
    private java.util.List<BuilderChainingChild> values = new java.util.ArrayList<>();
    private java.util.List<BuilderChainingChildBuilder<BuilderListChainingBuilder<PARENT>>> valuesBuilders = new java.util.ArrayList<>();

    private PARENT parent;

    public BuilderListChainingBuilder() {
    }

    public BuilderListChainingBuilder(PARENT parent) {
        this.parent = parent;
    }

    /**
     * This replaces the collection currently present. Any previous calls to addValues are not saved.
     */
    public BuilderListChainingBuilder<PARENT> withValues(java.util.List<BuilderChainingChild> values) {
        this.values = values;
        valuesBuilders = new java.util.ArrayList<>();
        return this;
    }

    /**
     * this will add the supplied objects to the collection present. If an unmodifiable collection is set using {@link #withValues(java.util.List)} then an Exception can be thrown.
     */
    public BuilderListChainingBuilder<PARENT> addValues(Iterable<? extends BuilderChainingChild> values) {
        for (BuilderChainingChild v : values) {
            this.values.add(v);
        }
        return this;
    }

    /**
     * this will add the supplied objects to the collection present. If an unmodifiable collection is set using {@link #withValues(java.util.List)} then an Exception can be thrown.
     */
    public BuilderListChainingBuilder<PARENT> addValues(BuilderChainingChild... values) {
        for (BuilderChainingChild v : values) {
            this.values.add(v);
        }
        return this;
    }

    /**
     * Each call to this method creates a new Builder which will be stored in the list. Use the end() method to return back to the current builder.
     */
    public BuilderChainingChildBuilder<? extends BuilderListChainingBuilder<PARENT>> addValues() {
        BuilderChainingChildBuilder<BuilderListChainingBuilder<PARENT>> child = new BuilderChainingChildBuilder<>(this);
        valuesBuilders.add(child);
        return child;
    }

    /**
     * returns the build object. For builder chaining use the {@link #end()} method to return the parent builder.
     */
    public BuilderListChaining build() {
        BuilderListChaining result = new BuilderListChaining();
        result.getValues().addAll(values);
        for (BuilderChainingChildBuilder<?> valuesBuilder : valuesBuilders) {
            result.getValues().add(valuesBuilder.build());
        }
        return result;
    }

    /**
     * returns the parent builder if present, otherwise null is returned.
     */
    public PARENT end() {
        return parent;
    }

    public static BuilderListChainingBuilder<Void> copyOf(BuilderListChaining bron) {
        if (bron == null) {
            return null;
        }
        BuilderListChainingBuilder<Void> builder = new BuilderListChainingBuilder<>();
        builder.valuesBuilders = new java.util.ArrayList<>();
        for (BuilderChainingChild original : bron.getValues()) {
            builder.valuesBuilders.add(BuilderChainingChildBuilder.copyOf(original, builder));
        }
        return builder;
    }

    public static <T> BuilderListChainingBuilder<T> copyOf(BuilderListChaining bron, T parentBuilder) {
        if (bron == null) {
            return null;
        }
        BuilderListChainingBuilder<T> builder = new BuilderListChainingBuilder<>(parentBuilder);
        builder.valuesBuilders = new java.util.ArrayList<>();
        for (BuilderChainingChild original : bron.getValues()) {
            builder.valuesBuilders.add(BuilderChainingChildBuilder.copyOf(original, builder));
        }
        return builder;
    }
}